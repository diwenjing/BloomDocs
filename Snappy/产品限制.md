##产品限制
RowStore对SQL语句，子句和表达式有限制和限制。<br/>
	
	基本数据库限制
	ALTER TABLE限制
	程序和功能限制
	自动生成的列限制
	LONG / LOB列限制
	批量更新限制
	级联删除不支持
	通过DDL锁定优先级DML
	到期和驱逐限制
	INSERT with Subselect限制
	LOCK TABLE不支持
	过程调用限制（数据感知和非数据感知过程）
	RENAME不支持
	可更新的结果集限制
	事务隔离级支持
	不支持事务的HA故障切换
	触发限制
	UNION，INTERSECT和EXCEPT操作员限制
	查看限制
	
##基本数据库限制
下表描述了与数据库对象和语句关联的基本限制。<br/>

|值|	限制|
|--|--|
|表中的最大列	|1012|
|视图中的最大列|	5000|
|存储过程中的最大参数数|	90|
|表上的最大索引|	32,767或存储容量|
|在SQL语句或视图中引用的最大表	|存储容量|
|选择列表中的最大元素|	1012|
|WHERE或HAVING子句中的最大谓词|	存储容量|
|GROUP BY子句中的最大列数|	32677|
|ORDER BY子句中的最大列数|	1012
|准备语句的最大数量|	存储容量|
|程序中最大声明的游标|	存储容量|
|一次打开的最大光标数|	存储容量|
|表上约束的最大数量|	存储容量|
|最大级别的子查询嵌套|	存储容量|
|单个语句中子查询的最大数量|	存储容量|
|工作单位最大行数更改|	存储容量|
|语句中的最大常数	|存储容量|
|级联触发器的最大深度	|16|


##ALTER TABLE限制
此版本的RowStore对ALTER TABLE有以下限制。如果尝试了以下任何操作，RowStore会使用SQLState“0A000”引发SQLException“功能未实现”  <br/>

如果一个表当前存储数据，或者一个分区表是否有数据分配的桶，则添加或删除主键约束（或主键列）。在分区表的情况下，如果插入任何数据，RowStore会为表数据分配桶，即使您使用DELETE从表中删除所有数据，也会保留这些存储桶。要删除分区表的数据和桶分配，请使用TRUNCATE TABLE。<br/>
删除用于表分区的列。<br/>
以下情况不支持在唯一列上存在外键时包含数据的表的唯一键：<br/>
外键列的一个子集是表的分区列，<br/>
外键列不配置。<br/>
Converseley试图在主表的唯一键列上添加外键约束失败，如果外键表列与主表并行定位不成功。<br/>
另外，描述SQL-92标准的ALTER COLUMN子句未被实现。RowStore仅支持ALTER COLUMN子句，用于将非标识列更改为GENERATED ALWAYS AS IDENTITY列。<br/>


程序和功能限制<br/>
RowStore不支持在过程或函数正文中执行DDL语句。<br/>


自动生成的列限制<br/>
此版本的RowStore支持自动生成的IDENTITY列，但具有以下限制：<br/>

只有INT和BIGINT列类型可以标记为自动生成的IDENTITY列。<br/>
START WITH和INCREMENT BY子句只支持GENERATED BY DEFAULT标识列。<br/>
如果在任何插入中达到类型的最大允许值，则RowStore将滚动到初始值（例如，达到值2147483647后，INT列的下一个生成的标识为-2147483647）。这并不一定意味着该类型的所有可能的值都已被使用，因为某些值可能还未被使用。<br/>
应用程序不应该依赖于跨分布式系统增量的标识值，因为RowStore不会为多个成员的并发插入提供排序保证。但是，来自单个成员的插入将按升序生成值，并且应用程序可以使用它来进行排序。<br/>





##LONG / LOB列限制
RowStore不支持在索引中使用以下数据类型的列，ORDER BY子句，GROUP BY子句，DISTINCT子句，UNION子句或其他集合操作：<br/>

##BLOB
##CLOB
用于位数据的长VARCHAR<br/>
在这些情况下，支持LONG VARCHAR类型的列。<br/>


##批量更新限制
如果SQL语句对多个RowStore成员执行批量更新操作，则在批量更新期间发生的任何异常都可能会更新某些行，而其他行未更新。使用批量更新语句的事务来确保所有更新成功或者整体回滚。请参阅原子性批量更新。
<br/>

级联删除不支持<br/>
RowStore不支持级联删除操作。<br/>


通过DDL锁定优先级DML<br/>
RowStore锁定行为通过DDL语句优先执行DML。如果您的系统正在处理大量并发DML和DDL语句，则DDL statments可能会收到锁超时异常（SQLState：40XL1）。您可以使用snappydata.max-lock-wait配置 DDL语句等待锁定的最大时间。<br/>


##到期和驱逐限制<br/>
EXPIRE ENTRY WITH IDLETIME仅在基于主键的查询被触发时才起作用。否则，当表扫描或索引扫描发生并且它被破坏时，系统将不会修改其访问时间。<br/>

不要在具有引用外键的子表的父表上设置具有DESTROY操作的EXPIRATION或EVICTION。这是由于RowStore中缺少级联删除支持。如果尝试创建一个有这样一个策略的表的外键引用的子表，那么抛出一个SQLException（SQLState：“X0Y99”）。<br/>

复制表不支持使用DESTROY操作进行删除。对于复制表支持OVERFLOW操作的驱逐，EXPIRE条款也是如此。
<br/>

##INSERT with Subselect限制
RowStore对使用子选择语句的INSERT语句的支持有限。不支持嵌套选择和选择具有聚合; 这些查询抛出一个功能未实现的异常（SQLSTATE 0A000）。<br/>


##LOCK TABLE不支持
此版本的RowStore不支持LOCK TABLE语句。<br/>


##过程调用限制（数据感知和非数据感知过程）
在CALL语句中使用ON TABLE扩展时，WHERE子句是必需的。如果您需要将数据感知过程路由到承载表的所有成员（不进行任何修剪），则必须指定一些始终计算为true的无关条件（例如WHERE 1 = 1）。<br/>

服务器只能处理与CREATE PROCEDURE语句中的JDBC参数类型完全匹配的Java过程定义。如果一个过程指定了使用相应java类型的基类的参数类型（例如，如果一个过程使用java.util.Date而不是java.sql.Date），那么从客户端调用将失败。
<br/>

RENAME不支持
RowStore不支持由SQL-92标准指定的RENAME语句。抛出状态为“0A000”的SQLException，尽管该语句未被视为语法错误。
<br/>

可更新的结果集限制
只有当使用包含FOR UPDATE子句的SQL查询从JDBC对等客户端连接获取结果集时，RowStore才支持可更新的结果集。例如，您不能使用以下JDBC命令来处理可更新的结果集：
<br/>
	Statement s = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_UPDATABLE);
	String sql = "select * from trade.networth where cid > " + lowCid + " and cid <= " + highCid;
	
	ResultSet updatableRs = s.executeQuery(sql);
RowStore不支持带有UPDATE或DELETE语句的WHERE CURRENT OF子句，可以使用可更新游标执行定位更新。
<br/>
SELECT ... FOR UPDATE不为瘦客户机连接提供可更新的结果集。任何尝试使用结果集更新行将导致异常或未定义的行为。但是，SELECT将在受影响的行上获取适当的锁，之后可以执行显式更新语句来更新行。使用JDBC对等客户端驱动程序。<br/>

如果语句不是事务的一部分，则SELECT ... FOR UPDATE语句不会锁定任何行。如果在事务上下文（隔离级别Connection.TRANSACTION_NONE）之外使用此语句，则会引发并记录SQLWarning。这是因为在非事务上下文中，在选择阶段期间不会获得适当的行锁，更新阶段可能会看到修改的行。
<br/>
在事务中，RowStore锁定SELECT ... FOR UPDATE语句中返回的所有行。它仅在结果集关闭后才会释放（使用ResultSet.close（）或由于事务提交或回滚）。
<br/>
RowStore不支持可保存的结果集（ResultSet.HOLD_CURSORS_OVER_COMMIT）。
<br/>

##事务隔离级支持
此版本的RowStore支持READ_COMMITTED，READ_UNCOMMITTED和REPEATABLE_READ事务隔离级别。任何使用READ_UNCOMMITTED级别的事务隐式升级为READ_COMMITTED。当没有指定任何内容时，JDBC操作使用TRANSACTION_NONE隔离，表示没有事务。但是，RowStore仍然提供某些数据一致性和原子性保证，如“了解数据一致性模型”中所述。<br/>

在应用程序中使用分布式事务提供了分布式事务实现和语义的概述。<br/>


##不支持事务的HA故障切换
此版本的RowStore不支持事务的透明故障切换。如果参与事务的成员在事务中或在提交期间中断，则提交将引发提交失败异常（SQLState：X0Z16），并且事务被回滚。同样，RowStore不支持将现有事务状态自动复制到加入系统的新成员。如果成员在事务中间连接分布式系统，该成员是事务中正在更新的其中一个表的数据存储，则事务将在提交时失败并回滚（SQLState：X0Z16）。请参阅回滚行为和成员失败。<br/>


##触发限制
此版本的RowStore不支持语句触发器。<br/>


##UNION，INTERSECT和EXCEPT操作员限制
RowStore不支持任何嵌套集合运算符或具有连接，函数表达式，SQL过程，视图或子查询的集合运算符的查询。在使用集合运算符的查询的任一子代的WHERE子句中，没有明确的支持为ORDER BY，GROUP BY或复合过滤器提供。此外，使用集合运算符的查询不支持事务和高可用性功能。<br/>

在这种情况下，集合运算符包括以下任何运算符：<br/>
UNION DISTINCT，UNION，UNION ALL，INTERSECT DISTINCT，INTERSECT，INTERSECT ALL，EXCEPT DISTINCT，EXCEPT或EXCEPT ALL。
<br/>

##查看限制
RowStore不支持在分区表上进行分组，聚合，不同或连接操作的视图。<br/>

###查询功能和限制 RowStore查询具有分布式数据库设计固有的一组独特的功能和限制。
<br/>

RowStore查询具有分布式数据库设计固有的一组独特的功能和限制。<br/>

多表查询的一般先决条件是查询中涉及的所有分区表必须位于相同的服务器组中。分区表的服务器组必须是查询中任何复制表的服务器组的子集。基本上，这意味着托管分区表数据存储的RowStore对等体也应该托管复制表。以这种方式配置服务器组可以使RowStore在本地在数据存储区上服务于涉及分区和复制表的等价。<br/>

根据涉及的表类型（复制或分区），不支持某些类型的等待查询和内部查询。分区或主键列不支持更新。<br/>

下表总结了对不同类型查询的RowStore支持。<br/>



|查询类型| 支持级别|  笔记|
|--|--|--|
|嵌套子查询| 有限| RowStore不支持具有多个嵌套级别的子查询。|
|单表查询 | 支持一些例外|  仅涉及单个表（分区或复制）的基本查询无任何限制。这包括具有聚合函数的查询，“group by”子句，“order by”子句等等。注意：RowStore不支持对包含“UNION”，“INTERSECTION”或“EXCEPT”子句的分区表的查询。引用分区表的查询不能包含“FROM”子句中的表查询。请参阅FROM子句中具有表查询的分区表查询。|
|涉及一个分区表和多个复制表的查询|  支持的  | 不受限制地支持涉及单个分区表的查询。请参阅单个分区表的查询。|
 |涉及两个或多个分区表的查询|  支持托管标准|涉及两个或多个分区表的查询必须满足托管标准。请参阅关于查询多个分区表的托管要求。|
|涉及多个分区表的外连接查询|支持托管标准|涉及两个或多个分区表的查询必须满足托管标准。请参阅多个分区表的外连接查询。|
|涉及单个分区表的外连接查询|支持的|请参阅单个分区表的查询。请参阅多个复制表和单个分区表的外连接查询。|
|具有分区表的外部查询的非相关子查询|支持的*|*支持分区和复制表的非关联查询。但是，RowStore可能会尝试将这些查询转换为等待查询。只有当查询满足托管标准时，才能进行此优化。具有分区表外部查询的非相关子查询|
|具有复制表外部查询的非相关子查询|支持的|具有复制表外部查询的非相关子查询|
|相关子查询与分区表的外部和内部查询|支持托管标准|涉及分区表的相关子查询必须满足托管标准。相关子查询与分区表的外部和内部查询|
|相关子查询与复制表的内部查询|支持的|相关子查询与复制表的内部查询|
|具有一个或多个分区表的复制表内部查询的外部查询的相关子查询|不支持|与分区表的复制表内部查询的外部查询相关的子查询|

以下部分使用以下一组示例表来描述查询支持和限制。<br/>
	create table trade.securities (sec_id int not null, symbol varchar(10) not null, 
	     price decimal (30, 20), exchange varchar(10) not null, tid int, constraint sec_pk primary key (sec_id) )replicate
	
	create table trade.customers (cid int not null, cust_name varchar(100), since date, addr varchar(100), tid int, primary key (cid)) 
	     partition by column (cust_name) 
	
	create table trade.portfolio (cid int not null, sid int not null, qty int not null, availQty int not null, subTotal decimal(30,20), 
	     tid int, constraint portf_pk primary key (cid, sid), constraint cust_fk foreign key (cid) references trade.customers (cid) on delete restrict, 
	     constraint sec_fk foreign key (sid) references trade.securities (sec_id)) partition by column (cid) colocate with (trade.customers) 
	
	create table trade.sellorders (oid int not null constraint orders_pk primary key, cid int, sid int, qty int, ask decimal (30, 20), 
	     status varchar(10) default 'open', tid int, constraint portf_fk foreign key (cid, sid) references trade.portfolio (cid, sid)) replicate 
	
	create table trade.networth (cid int not null, cash decimal (30, 20), securities decimal (30, 20), loanlimit int, availloan decimal (30, 20), 
	     tid int, constraint netw_pk primary key (cid), constraint cust_newt_fk foreign key (cid) references trade.customers (cid) on delete restrict ) 
	     partition by column (cid) colocate with(trade.customers) 
	
	create table trade.buyorders(oid int not null constraint buyorders_pk primary key, cid int, sid int, qty int, bid decimal (30, 20), status varchar(10), 
	     tid int, constraint bo_sec_fk foreign key (sid) references trade.securities (sec_id) on delete restrict) partition by column (cid)
在上述制度中，证券和卖家是复制表，而客户，投资组合，网络和买方则是分区表。投资组合和网络表与客户共享，在cid列上分区。购买者表不与任何分区表共同配置。<br/>

所有表都分配给默认服务器组。<br/>


###查询单个分区表
仅涉及一个分区表（也可能是多个复制表）的简单查询工作没有任何限制。例如，支持以下每个查询：<br/>

	select * from trade.portfolio, trade.securities, trade.sellorders
	select * from trade.securities s, trade.portfolio f where sec_id = f.sid and f.tid = ?
	select * from trade.securities s, trade.portfolio f, trade.sellorders so where s.sec_id = f.sid and so.sid = s.sec_id and f.tid = ?
	<br/>

关于查询多个分区表的托管要求<br/>
仅当满足这两个共享标准的情况下才支持涉及两个或多个分区表（有或没有其他复制表）的查询：<br/>

query的WHERE子句在查询中的所有分区表的所有分区列上都具有equijoin条件。<br/>
查询中的所有分区表都是共同的。<br/>
这些标准允许RowStore将连接查询分发到承载数据的所有数据存储。查询在每个本地数据存储上同时执行，而不必将表数据从一个成员移动到另一个成员进行连接。连接在每个数据存储的本地数据集上执行，并且主查询成员聚合来自每个数据存储的结果以获得结果集。<br/>

当确定托管时，请注意，如果表B与表A并置，并且表C与表A共同配置，那么表B和C也是共同定位的。类似地，如果表C与表B共同定位，并且B与表A共同定位，则表C和A也被共同定位。例如，考虑以下查询：<br/>

     select * from trade.customers c, trade.securities s, trade.portfolio f where c.cid = f.cid and sec_id = f.sid and f.tid = ?
上面的查询具有等价条件c.cid = f.cid，它将分区列portfolio和customers表关联cid。这两个表共同配置cid，因此RowStore可以执行此查询。表securities复制的事实不会对等待标准施加任何要求。<br/>

以下示例显示了满足等效要求的示例查询：<br/>

     select * from trade.customers c, trade.networth n, trade.portfolio p where n.cid = c.cid and n.cid = p.cid and n.tid = ? and c.cid >?
上面的查询涉及三个分区表。由于networth表与之共同配置customers并portfolio与之共同配置customers，因此三个表互为共同位置。每个表的分区列与另一个表的等连接条件形成。存在两个等式连接条件n.cid = c.cid并n.cid = p.cid满足托管标准，因此RowStore可以执行此查询。<br/>

请记住，必须满足托管标准。即使查询中的分区表被共同定位，RowStore也不支持将连接条件应用于非分区列的查询。这种类型的查询仅满足一个但不仅仅是两个标准。例如，即使两个表customers和portfolio表都是共同定位的，RowStore不支持此查询，因为tid它不是分区列：<br/>

     select * from trade.customers c, trade.portfolio f where c.tid = f.tid
类似地，不支持对非共处理分区表的连接查询。此查询在两个表的分区列上都具有等价条件，但RowStore无法执行，因为这些表不是共同定位的：<br/>

     select * trade.buyorders b, trade.customers c where b.cid = c.cid
最后，RowStore不支持涉及不具有连接条件的多个分区表的查询。例如，不支持此查询：<br/>

     Select * from trade.customers c, trade.portfolio f where f.tid = ?

多个分区表的外连接查询<br/>
为了对多个分区表执行外部连接，必须满足托管标准，这需要分区列上的连接条件。例如，考虑查询：<br/>
	
	select * from trade.customers c LEFT OUTER JOIN trade.portfolio f LEFT OUTER JOIN trade.sellorders so on f.cid = so.cid on c.cid= f.cid where f.tid = ?
此查询涉及两个分区表和一个复制表。因为cid列是分区列customers和portfolio表，所以RowStore可以执行查询。<br/>


外部连接查询多个复制表和单个分区表<br/>
支持仅涉及一个分区表（可能还有多个复制表）的外连接查询，而不符合任何其他条件。例如，RowStore可以执行此查询，因为它只引用一个分区表：<br/>
	
	select * from trade.portfolio f LEFT OUTER JOIN trade.sellorders so on f.cid = so.cid on c.cid= f.cid where f.tid = ? 

具有分区表外部查询的非相关子查询<br/>
RowStore支持不相关的子查询，其中外部查询表被分区，并且内部查询表被复制或分区。但是，如果满足托管标准，RowStore只会将独立查询优化为等于连接查询。如果托管标准不满足，RowStore会独立地评估子查询（使用map和reduce函数）。<br/>

例如，RowStore这个查询转换成等值连接查询，因为customer和portfolio在同一位置上cid：<br/>
	
	select * from trade.customers c where c.cid IN (select f.cid from trade.portfolio f where qty > 297) and tid =?
	RowStore执行此查询而不将其转换为等待，因为这些表不在以下位置上tid：<br/>
	
	select * from trade.customers c where c.tid IN (select f.tid from trade.portfolio f where qty > 297)
	该查询也通过将其转换为等待执行，因为内部表是复制的，并且不需要托管标准：<br/>
	
	select * from trade.portfolio f where f.sid IN ( select sec_id from trade.securities ).

具有复制表外部查询的非相关子查询<br/>
RowStore支持复制外部查询表并且内部查询表被复制或分区的非关联子查询。如果内部查询表被复制，RowStore可以将独立查询优化为等连接查询。如果内部查询表被分区，那么RowStore执行查询而不尝试等待转换。<br/>

例如，RowStore执行此查询而不将其转换为等待，因为内部查询表被分区：<br/>
	
	select * from trade.securities s where s.sec_id IN ( select f.sid from trade.portfolio f ) and s.tid = ?
	RowStore将此查询转换为等价，因为内部和外部查询表都被复制：<br/>
	
	select * from trade.securities s where s.sec_id IN ( select so.sid from trade.sellorders so ) and s.tid = ?

相关子查询与分区表的外部和内部查询<br/>
只有当查询满足托管标准时，RowStore才能执行具有分区表的内部和外部查询的关联子查询。<br/>

例如，RowStore可以执行，因为一个等值连接状态上存在的这个查询cid的列customers和portfolio表：<br/>

	select * from trade.customers c where exists (select * from trade.portfolio f where c.cid = f.cid and qty > 297) and tid =?

相关子查询与复制表的内部查询
当内部查询针对复制表且外部查询针对分区或复制表时，RowStore可以执行相关子查询。<br/>

例如，以下查询包含两个相关的子查询。RowStore可以执行第一个子查询，因为这两个表customers和portfolio表都满足托管标准，并且它可以执行第二个子查询，因为内部查询与复制表相对应sellorders。<br/>

	select * from trade.customers c where EXISTS (select * from trade.portfolio f where c.cid = f.cid and tid =?) 
	   and NOT EXISTS (select * from trade.sellorders s where c.cid = s.cid and status IN ('open','filled'))
表子查询在From条款中包含表表达式并涉及分区表<br/>


在FROM子句中查询具有表查询的分区表<br/>
包含分区表的任何查询都不能在FROM子句中包含表查询。例如，RowStore无法执行此查询，因为该FROM子句包含一个表子查询，该查询引用了一个分区表：<br/>

    select * from (select cid, sid, qty, tid from trade.portfolio f) where tid = 7

与分区表的复制表内部查询的外部查询相关的子查询<br/>
如果外部查询仅涉及复制表，则相关子查询中的分区表的存在会使查询与RowStore不兼容。例如，RowStore无法执行查询：<br/>

	select sec_id, price from securities s 
	     where price > (select Avg(qty) from portfolio f where sec_id = f.sid and f.tid =4 and qty <> 0 ) and tid =4
	
	
	



























以下部分使用以下一组示例表来描述查询支持和限制。

create table trade.securities (sec_id int not null, symbol varchar(10) not null, 
     price decimal (30, 20), exchange varchar(10) not null, tid int, constraint sec_pk primary key (sec_id) )replicate

create table trade.customers (cid int not null, cust_name varchar(100), since date, addr varchar(100), tid int, primary key (cid)) 
     partition by column (cust_name) 

create table trade.portfolio (cid int not null, sid int not null, qty int not null, availQty int not null, subTotal decimal(30,20), 
     tid int, constraint portf_pk primary key (cid, sid), constraint cust_fk foreign key (cid) references trade.customers (cid) on delete restrict, 
     constraint sec_fk foreign key (sid) references trade.securities (sec_id)) partition by column (cid) colocate with (trade.customers) 

create table trade.sellorders (oid int not null constraint orders_pk primary key, cid int, sid int, qty int, ask decimal (30, 20), 
     status varchar(10) default 'open', tid int, constraint portf_fk foreign key (cid, sid) references trade.portfolio (cid, sid)) replicate 

create table trade.networth (cid int not null, cash decimal (30, 20), securities decimal (30, 20), loanlimit int, availloan decimal (30, 20), 
     tid int, constraint netw_pk primary key (cid), constraint cust_newt_fk foreign key (cid) references trade.customers (cid) on delete restrict ) 
     partition by column (cid) colocate with(trade.customers) 

create table trade.buyorders(oid int not null constraint buyorders_pk primary key, cid int, sid int, qty int, bid decimal (30, 20), status varchar(10), 
     tid int, constraint bo_sec_fk foreign key (sid) references trade.securities (sec_id) on delete restrict) partition by column (cid)
在上述制度中，证券和卖家是复制表，而客户，投资组合，网络和买方则是分区表。投资组合和网络表与客户共享，在cid列上分区。购买者表不与任何分区表共同配置。

所有表都分配给默认服务器组。


查询单个分区表
仅涉及一个分区表（也可能是多个复制表）的简单查询工作没有任何限制。例如，支持以下每个查询：

	select * from trade.portfolio, trade.securities, trade.sellorders
	select * from trade.securities s, trade.portfolio f where sec_id = f.sid and f.tid = ?
	select * from trade.securities s, trade.portfolio f, trade.sellorders so where s.sec_id = f.sid and so.sid = s.sec_id and f.tid = ?

关于查询多个分区表的托管要求
仅当满足这两个共享标准的情况下才支持涉及两个或多个分区表（有或没有其他复制表）的查询：

query的WHERE子句在查询中的所有分区表的所有分区列上都具有equijoin条件。
查询中的所有分区表都是共同的。
这些标准允许RowStore将连接查询分发到承载数据的所有数据存储。查询在每个本地数据存储上同时执行，而不必将表数据从一个成员移动到另一个成员进行连接。连接在每个数据存储的本地数据集上执行，并且主查询成员聚合来自每个数据存储的结果以获得结果集。

当确定托管时，请注意，如果表B与表A并置，并且表C与表A共同配置，那么表B和C也是共同定位的。类似地，如果表C与表B共同定位，并且B与表A共同定位，则表C和A也被共同定位。例如，考虑以下查询：

    select * from trade.customers c, trade.securities s, trade.portfolio f where c.cid = f.cid and sec_id = f.sid and f.tid = ?
上面的查询具有等价条件c.cid = f.cid，它将分区列portfolio和customers表关联cid。这两个表共同配置cid，因此RowStore可以执行此查询。表securities复制的事实不会对等待标准施加任何要求。

以下示例显示了满足等效要求的示例查询：

    select * from trade.customers c, trade.networth n, trade.portfolio p where n.cid = c.cid and n.cid = p.cid and n.tid = ? and c.cid >?
上面的查询涉及三个分区表。由于networth表与之共同配置customers并portfolio与之共同配置customers，因此三个表互为共同位置。每个表的分区列与另一个表的等连接条件形成。存在两个等式连接条件n.cid = c.cid并n.cid = p.cid满足托管标准，因此RowStore可以执行此查询。

请记住，必须满足托管标准。即使查询中的分区表被共同定位，RowStore也不支持将连接条件应用于非分区列的查询。这种类型的查询仅满足一个但不仅仅是两个标准。例如，即使两个表customers和portfolio表都是共同定位的，RowStore不支持此查询，因为tid它不是分区列：

    select * from trade.customers c, trade.portfolio f where c.tid = f.tid
类似地，不支持对非共处理分区表的连接查询。此查询在两个表的分区列上都具有等价条件，但RowStore无法执行，因为这些表不是共同定位的：

    select * trade.buyorders b, trade.customers c where b.cid = c.cid
最后，RowStore不支持涉及不具有连接条件的多个分区表的查询。例如，不支持此查询：

    Select * from trade.customers c, trade.portfolio f where f.tid = ?

多个分区表的外连接查询
为了对多个分区表执行外部连接，必须满足托管标准，这需要分区列上的连接条件。例如，考虑查询：

    select * from trade.customers c LEFT OUTER JOIN trade.portfolio f LEFT OUTER JOIN trade.sellorders so on f.cid = so.cid on c.cid= f.cid where f.tid = ?
此查询涉及两个分区表和一个复制表。因为cid列是分区列customers和portfolio表，所以RowStore可以执行查询。


外部连接查询多个复制表和单个分区表
支持仅涉及一个分区表（可能还有多个复制表）的外连接查询，而不符合任何其他条件。例如，RowStore可以执行此查询，因为它只引用一个分区表：

    select * from trade.portfolio f LEFT OUTER JOIN trade.sellorders so on f.cid = so.cid on c.cid= f.cid where f.tid = ? 

具有分区表外部查询的非相关子查询
RowStore支持不相关的子查询，其中外部查询表被分区，并且内部查询表被复制或分区。但是，如果满足托管标准，RowStore只会将独立查询优化为等于连接查询。如果托管标准不满足，RowStore会独立地评估子查询（使用map和reduce函数）。

例如，RowStore这个查询转换成等值连接查询，因为customer和portfolio在同一位置上cid：

    select * from trade.customers c where c.cid IN (select f.cid from trade.portfolio f where qty > 297) and tid =?
RowStore执行此查询而不将其转换为等待，因为这些表不在以下位置上tid：

    select * from trade.customers c where c.tid IN (select f.tid from trade.portfolio f where qty > 297)
该查询也通过将其转换为等待执行，因为内部表是复制的，并且不需要托管标准：

    select * from trade.portfolio f where f.sid IN ( select sec_id from trade.securities ).

具有复制表外部查询的非相关子查询
RowStore支持复制外部查询表并且内部查询表被复制或分区的非关联子查询。如果内部查询表被复制，RowStore可以将独立查询优化为等连接查询。如果内部查询表被分区，那么RowStore执行查询而不尝试等待转换。

例如，RowStore执行此查询而不将其转换为等待，因为内部查询表被分区：

     select * from trade.securities s where s.sec_id IN ( select f.sid from trade.portfolio f ) and s.tid = ?
RowStore将此查询转换为等价，因为内部和外部查询表都被复制：

    select * from trade.securities s where s.sec_id IN ( select so.sid from trade.sellorders so ) and s.tid = ?

相关子查询与分区表的外部和内部查询
只有当查询满足托管标准时，RowStore才能执行具有分区表的内部和外部查询的关联子查询。

例如，RowStore可以执行，因为一个等值连接状态上存在的这个查询cid的列customers和portfolio表：

    select * from trade.customers c where exists (select * from trade.portfolio f where c.cid = f.cid and qty > 297) and tid =?

相关子查询与复制表的内部查询
当内部查询针对复制表且外部查询针对分区或复制表时，RowStore可以执行相关子查询。

例如，以下查询包含两个相关的子查询。RowStore可以执行第一个子查询，因为这两个表customers和portfolio表都满足托管标准，并且它可以执行第二个子查询，因为内部查询与复制表相对应sellorders。

    select * from trade.customers c where EXISTS (select * from trade.portfolio f where c.cid = f.cid and tid =?) 
    and NOT EXISTS (select * from trade.sellorders s where c.cid = s.cid and status IN ('open','filled'))
表子查询在From条款中包含表表达式并涉及分区表


在FROM子句中查询具有表查询的分区表
包含分区表的任何查询都不能在FROM子句中包含表查询。例如，RowStore无法执行此查询，因为该FROM子句包含一个表子查询，该查询引用了一个分区表：

    select * from (select cid, sid, qty, tid from trade.portfolio f) where tid = 7

与分区表的复制表内部查询的外部查询相关的子查询
如果外部查询仅涉及复制表，则相关子查询中的分区表的存在会使查询与RowStore不兼容。例如，RowStore无法执行查询：

     select sec_id, price from securities s 
     where price > (select Avg(qty) from portfolio f where sec_id = f.sid and f.tid =4 and qty <> 0 ) and tid =4
