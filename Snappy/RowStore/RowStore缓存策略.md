# RowStore缓存策略 #
您可以将RowStore部署为传统关系数据库系统中管理的数据的分布式缓存。RowStore提供了将该产品用作数据库缓存的几种策略。<br/>

- **自动生成键的注意事项**

- **懒惰-加载缓存**

- **预装策略**

- **与Hibernate集成**

- **导出和转换现有模式**

## 自动生成键的注意事项 ##
如果缓存的表需要自动生成标识列值，那么您应该使用RowStore自动生成键值，但禁用后端数据库中的生成的键。如果后端数据库还生成键值，则如果RowStore已生成密钥，则插入可能会失败。<br/>

> 注意： RowStore支持自动生成标识列值，但不支持生成一系列键值。如果需要一个序列，那么在将行插入到RowStore之前，请考虑使用存储过程从后端数据库获取下一个序列值。

> 注意：当您使用RowStore DBSynchronizer实现来同步具有标识列的表时，默认情况下，标识列值不会自动应用于同步的数据库。DBSynchronizer期望后端数据库表也有一个标识列，数据库生成自己的标识值。如果您希望DBSynchronizer将相同的RowStore生成的标识列值应用于底层数据库，则在DBSynchronizer属性文件中设置“skipIdentityColumns = false”。请参阅**配置和使用DBSynchronizer**。


## 懒惰 - 加载缓存 ##

首先在RowStore中尝试应用程序查询请求。在一个小姐的时候，一个实现延迟加载的加载器被调用，它可以从后台数据库中获取数据。当表被延缓加载时，RowStore仅支持基于主键的查询。确定RowStore中缺少的行的子集是不切实际的（太贵），并且构造一个仅向后端数据库提取缺省行的查询。通常情况下，应用程序可以配置最近最少使用的（LRU）缓存，缓存通过排除最不常用的行优化可用内存。应用程序只能对配置为逐出的表发出基于主键的查询。有关更多信息，请参阅**使用RowLoader加载现有数据**。<br/>

所有更新可以使用“writer”或内置的DBSynchronizer同步或异步地写回数据库。对于与后端数据库结构相同的表，如果配置后端数据库的数据库URL，应用程序可以异步地“写入”。<br/>


## 预装策略 ##
RowStore提供了几种涉及预加载数据的缓存策略。

- **预加载数据库**。在Bootstrap时间将整个数据库加载到RowStore。如果所有更新都通过RowStore，则无需从后端数据库重新同步该状态。数据引导过程如下。通过此选择，表将从后端数据库加载整个数据集，所有查询都可以直接在RowStore数据存储上执行。

- **预加载“热”数据，并懒惰其余**。如果后端数据库中设置的数据量非常大，则更好的选择是维护RowStore中的所有“热”表，并将历史数据加载到“历史”表中。通过这种设计，整个支持的SQL语法可以在完全填充的“热”表上使用，但只有基于主键的查询可以在历史表上发布。通常，这些历史表将被配置为LRU驱逐。

与Hibernate集成
RowStore还可以集成在诸如Hibernate的对象关系映射产品中，并提供L2缓存 - 整个查询结果集可以在RowStore中缓存。使用Hibernate API完成的更新将同步传播到数据库，查询结果集将在RowStore中无效。

有关在Hibernate项目中使用RowStore方言文件的信息，请参阅**RowStore Hibernate方言**。

## 导出和转换现有模式 ##
应用程序开发人员可以使用的工具，如DdlUtils出口现有的关系数据库模式，把它转换为RowStore，并与数据一起导入新的架构成RowStore集群。