#复制表
RowStore服务器组控制哪些RowStore数据存储成员复制表的数据。当在集群中初始化新表并且更新复制表时，RowStore会复制表数据。<br/>



- **RowStore如何复制表** RowStore与目标服务器组中的每个表副本同步复制复制表的每一行。通过同步复制，表读取可以均匀地平衡到集群中的任何副本，而没有一个成员成为争用点。<br/>


- **决定何时使用复制表** 代码表通常是复制的好候选者。<br/>



- **创建复制表** 您可以使用语句显式或默认创建复制表<code>CREATE TABLE。</code><br/>

##RowStore如何复制表
RowStore将复制表的每一行与目标服务器组中的每个表副本同步复制。通过同步复制，表读取可以均匀地平衡到集群中的任何副本，而没有一个成员成为争用点。<br/>

RowStore将数据复制到创建表的服务器组中的所有对等体。复制通过TCP通道与其他对等体并行发生。<br/>

当在集群中初始化新表并且更新复制表时，RowStore会复制表数据。<br/>


###初始化时的复制
当在对等体或服务器中创建非持久性（“仅内存”）复制表时，它将使用承载表的服务器组的另一个成员的数据来初始化自身。选择服务器组中的单个数据存储成员，并从该成员流式传输表的数据以初始化新副本。如果所选成员在复制过程中失败，则初始化过程将选择服务器组中的其他成员来流式传输数据。<br/>


###更新期间的复制
当应用程序更新复制表时，RowStore会使用集群的各个成员之间的网络带宽并行将更新分发到所有副本。发送对等体或服务器在本地锁定更新的行，然后将更新分发到副本。在每个副本处理更新并使用确认消息进行响应后，起始RowStore对等体将控制权返回给应用程序。更新过程是保守的，以确保复制表的所有副本都包含一致的数据。每个接收器完全处理更新，在必要时应用约束检查，并在响应确认之前更新本地表数据。无论读取或更新多少列，单个行键上的每个操作都以原始方式执行。<br/>

##决定何时使用复制表
代码表通常是复制的好候选者。<br/>

应用数据经常被标准化以维持“事实”表中的“代码”字段，并且维护与相关联的“维度”表中的每个“代码”相关联的细节。代码表通常很小，而且很少更改，但是它们经常与查询中的父“事实”表相连。这种代码表是使用复制表的好选择。<br/>

另请注意，此版本的RowStore仅支持在共址数据上连接。而不是在所有情况下使用分区，您应该考虑让应用程序复制与其他分区表连接的较小表。<br/>


> 注意：如果多个应用程序在事务之外的同一时间更新复制表的同一行，则当RowStore复制这些更新时，表数据可能会失去同步。使用复制表时，请注意此限制。<br/>

##创建复制表
您可以使用语句显式或默认创建复制表`CREATE TABLE`。

当执行CREATE TABLE语句并且不包括PARTITIONING子句时，RowStore默认创建一个复制表。您还可以使用`REPLICATE`语句中的子句显式创建复制表`CREATE TABLE`。例如：

    CREATE TABLE COUNTRIES
       (
      	  COUNTRY VARCHAR(26) NOT NULL CONSTRAINT COUNTRIES_UNQ_NM Unique,
      	  COUNTRY_ISO_CODE CHAR(2) NOT NULL CONSTRAINT COUNTRIES_PK PRIMARY KEY,
      	  REGION VARCHAR(26),
      	  CONSTRAINT COUNTRIES_UC
      	  CHECK (country_ISO_code = upper(country_ISO_code) )
       ) REPLICATE;
因为此命令省略了SERVER GROUPS子句，所以该示例创建“countries”表，并将模式的默认服务器组的所有成员复制表的数据（默认服务器组中的所有对等体和服务器将`host-data`属性设置为true） 。

